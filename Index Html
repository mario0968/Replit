// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

interface AggregatorV3Interface {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
}

contract ShibaxPresale is ReentrancyGuard {
    // ===== Token & Wallet Adresses =====
    IERC20 public sbxToken = IERC20(0xA297D42fB6cd1b29DCa8F61BCDad145272a64781);
    IERC20 public usdtToken = IERC20(0x55d398326f99059fF775485246999027B3197955);
    address public receiver = 0x30aD6EC210642Ed4E514D285280A2028aE0C0cbe;

    // ===== Presale Variables =====
    uint256 public totalRaised;
    uint256 public minBuy = 50 * 1e18;           // 50 USD
    uint256 public maxBuy = 200_000 * 1e18;     // 200,000 USD

    uint256 public price = 2 * 1e14;            // Initial price per SBX in USD (18 decimals)
    uint256 public priceIncrement = 5 * 1e14;   // Price increment per tranche
    uint256 public stageTarget = 2_000_000 * 1e18; // Each tranche triggers price increase
    uint256 public currentStage = 1;            // Counts tranches

    mapping(address => uint256) public contributedUSD;

    // ===== Chainlink Price Feeds (BSC Mainnet) =====
    AggregatorV3Interface public priceFeedBNB = AggregatorV3Interface(0x0567F2323251f0Aab15c8DfB1967E4e8A7D42aeE);
    AggregatorV3Interface public priceFeedETH = AggregatorV3Interface(0x9ef1a10A0F0EaE3fFf9e42E2f70dA6bDfAA243e8);
    AggregatorV3Interface public priceFeedUSDT = AggregatorV3Interface(0x92C09849638959196E976289418e5973CC96d645);

    // ===== Events =====
    event Withdraw(address indexed to, uint256 amount);
    event TokenPurchase(address indexed buyer, uint256 usdAmount, uint256 tokenAmount, string currency);
    event StageUpdated(uint256 newStage, uint256 newPrice);

    // ===== Modifiers =====
    modifier validBuy(uint256 usdAmount) {
        require(usdAmount >= minBuy, "Below min purchase");
        require(contributedUSD[msg.sender] + usdAmount <= maxBuy, "Above max limit");
        _;
    }

    // ===== Buy Functions =====
    function buyWithUSDT(uint256 usdtAmount) external nonReentrant {
        uint256 usdAmount = _usdtToUSD(usdtAmount);
        _validateAndBuy(msg.sender, usdAmount, "USDT");
        require(usdtToken.transferFrom(msg.sender, receiver, usdtAmount), "USDT transfer failed");
    }

    function buyWithBNB() public payable nonReentrant {
        uint256 usdAmount = _bnbToUSD(msg.value);
        _validateAndBuy(msg.sender, usdAmount, "BNB");
        (bool sent, ) = receiver.call{value: msg.value}("");
        require(sent, "BNB send failed");
    }

    function buyWithETH() public payable nonReentrant {
        uint256 usdAmount = _ethToUSD(msg.value);
        _validateAndBuy(msg.sender, usdAmount, "ETH");
        (bool sent, ) = receiver.call{value: msg.value}("");
        require(sent, "ETH send failed");
    }

    // ===== Internal Purchase Logic =====
    function _validateAndBuy(address buyer, uint256 usdAmount, string memory currency) internal validBuy(usdAmount) {
        uint256 tokenAmount = (usdAmount * 1e18) / price;
        require(sbxToken.balanceOf(address(this)) >= tokenAmount, "Not enough tokens");
        contributedUSD[buyer] += usdAmount;
        totalRaised += usdAmount;
        sbxToken.transfer(buyer, tokenAmount);
        _updateStage();
        emit TokenPurchase(buyer, usdAmount, tokenAmount, currency);
    }

    // ===== Stage & Price Update (Unlimited) =====
    function _updateStage() internal {
        // Each tranche of 2M USD increases the price
        if (totalRaised >= currentStage * stageTarget) {
            currentStage += 1;
            price += priceIncrement;
            emit StageUpdated(currentStage, price);
        }
    }

    // ===== Price Conversion =====
    function _bnbToUSD(uint256 amount) internal view returns (uint256) {
        (, int256 feedPrice, , , ) = priceFeedBNB.latestRoundData();
        require(feedPrice > 0, "Invalid BNB price");
        return (amount * uint256(feedPrice)) / 1e8;
    }

    function _ethToUSD(uint256 amount) internal view returns (uint256) {
        (, int256 feedPrice, , , ) = priceFeedETH.latestRoundData();
        require(feedPrice > 0, "Invalid ETH price");
        return (amount * uint256(feedPrice)) / 1e8;
    }

    function _usdtToUSD(uint256 amount) internal view returns (uint256) {
        (, int256 feedPrice, , , ) = priceFeedUSDT.latestRoundData();
        require(feedPrice > 0, "Invalid USDT price");
        return (amount * uint256(feedPrice)) / 1e8;
    }

    // ===== Withdraw Function =====
    function withdrawTokens(address to, uint256 amount) external {
        require(msg.sender == receiver, "Only receiver");
        sbxToken.transfer(to, amount);
        emit Withdraw(to, amount);
    }

    // ===== Fallback / Receive =====
    receive() external payable {
        buyWithBNB();
    }

    fallback() external payable {
        buyWithBNB();
    }
}
